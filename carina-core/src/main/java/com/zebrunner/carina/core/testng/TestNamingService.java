/*******************************************************************************
 * Copyright 2020-2022 Zebrunner Inc (https://www.zebrunner.com).
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *******************************************************************************/
package com.zebrunner.carina.core.testng;

import java.lang.invoke.MethodHandles;
import java.lang.reflect.Parameter;
import java.util.Arrays;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.atomic.AtomicInteger;

import org.apache.commons.lang3.StringUtils;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.testng.ITestContext;
import org.testng.ITestNGMethod;
import org.testng.ITestResult;

import com.qaprosoft.carina.core.foundation.dataprovider.core.DataProviderFactory;
import com.zebrunner.agent.testng.listener.RunContextService;
import com.zebrunner.carina.utils.Configuration;
import com.zebrunner.carina.utils.commons.SpecialKeywords;

public class TestNamingService {
    private static final Logger LOGGER = LoggerFactory.getLogger(MethodHandles.lookup().lookupClass()); 
    
    static final ThreadLocal<String> testName = new ThreadLocal<String>();
    private static final ConcurrentHashMap<String, AtomicInteger> testNameInvCounter = new ConcurrentHashMap<>();

    /**
     * Get full test name based on test class, method and other generic information. It is generated by TestNameListener automatically.
     * 
     * @return String test name
     */
    @Deprecated
    public static String getTestName() {
        // TODO: think about returning very simple valid name if nothing was specified yet! Need ITestResult arg for that!
        if (testName.get() == null) {
            throw new RuntimeException("Unable to detect full test name yet!");
        }
        return testName.get();
    }
    
    /**
     * Get full test name based on test class, method and other generic information. It is generated by TestNameListener automatically.
     * 
     * @param result ITestResult
     * @return String test name
     */    
    public static String getTestName(ITestResult result) {
        // do not return name by thread because it is external Zafira call which should override all values
        setTestName(result);
        return testName.get();
    }
    
    /**
     * Set any custom full test name.
     * 
     * @param name String
     * @return String test name
     */ 
    public static String setTestName(String name) {
        LOGGER.warn("Overridden testName: " + name);
        testName.set(name);
        return testName.get();
    }

    
    /**
     * Set full test name based on test class, method and other generic information. It is generated based by ITestResult object.
     * 
     * @param result ITestResult
     * @return String test name
     */     
    @SuppressWarnings("unlikely-arg-type")
    private static String setTestName(ITestResult result) {
        String name = StringUtils.EMPTY;
        if (result.getTestContext() == null) {
            throw new RuntimeException("Unable to set Test name without testContext!");
        }

        ITestNGMethod method = result.getMethod();

        name = Configuration.get(Configuration.Parameter.TEST_NAMING_PATTERN);
        name = name.replace(SpecialKeywords.TEST_NAME, getTestNameMapName(result))
                .replace(SpecialKeywords.TEST_NAME_TUID, getMethodTUID(result))
                .replace(SpecialKeywords.METHOD_NAME, method.getMethodName())
                .replace(DataProviderFactory.DATA_SOURCE_UID_ARG_PATTERN, getDataSourceUid(result))
                .replace(SpecialKeywords.METHOD_PRIORITY, String.valueOf(method.getPriority()))
                .replace(SpecialKeywords.METHOD_THREAD_POOL_SIZE, String.valueOf(method.getThreadPoolSize()))
                .replace(SpecialKeywords.METHOD_GROUP_NAMES, String.join(", ", method.getGroups()))
                .replace(SpecialKeywords.METHOD_DESCRIPTION, String.valueOf(method.getDescription()))
                .replace(SpecialKeywords.TEST_NAME_CLASS, method.getTestClass().getRealClass().getSimpleName())
                .trim();

        LOGGER.debug("testName: {}", name);

        // introduce invocation count calculation here as in multi threading mode TestNG doesn't provide valid
        // getInvocationCount() value
        name = appendDataProviderLine(result, name);
        name = appendInvocationCount(result, name);

        testName.set(name);
        return testName.get();
    }

    private static String getDataSourceUid(ITestResult result) {
        String uid = StringUtils.EMPTY;

        @SuppressWarnings("unchecked")
        Map<String, String> uidMap = (Map<String, String>) result.getTestContext()
                .getAttribute(
                        DataProviderFactory.constructCustomDPAttributeUUID(DataProviderFactory.DATA_SOURCE_UID_ARG_ATTRIBUTE, result.getMethod()));

        if (uidMap != null) {
            // get uid of custom dataprovider
            String testHash = String.valueOf(Arrays.hashCode(result.getParameters()));
            if (uidMap.containsKey(testHash)) {
                uid = uidMap.get(testHash);
            }
        }

        return !uid.isEmpty() ? "[" + uid + "]" : uid;
    }

    private static String getTestNameMapName(ITestResult result) {
        String testName = StringUtils.EMPTY;

        @SuppressWarnings("unchecked")
        Map<String, String> testNameMap = (Map<String, String>) result.getTestContext()
                .getAttribute(DataProviderFactory.constructCustomDPAttributeUUID(SpecialKeywords.TEST_NAME_ARGS_MAP, result.getMethod()));

        if (testNameMap != null) {
            // get test name of custom dataprovider
            String testHash = String.valueOf(Arrays.hashCode(result.getParameters()));
            if (testNameMap.containsKey(testHash)) {
                testName = testNameMap.get(testHash);
            }
        } else {
            testName = result.getTestContext().getCurrentXmlTest().getName();
        }

        return testName;
    }

    private static String getMethodTUID(ITestResult result) {
        String methodUID = StringUtils.EMPTY;

        @SuppressWarnings("unchecked")
        Map<String, String> tuidMap = (Map<String, String>) result.getTestContext()
                .getAttribute(
                        DataProviderFactory.constructCustomDPAttributeUUID(DataProviderFactory.TUID_ARGS_MAP_CONTEXT_ATTRIBUTE, result.getMethod()));

        if (tuidMap != null) {
            // get test name of custom dataprovider
            String testHash = String.valueOf(Arrays.hashCode(result.getParameters()));
            if (tuidMap.containsKey(testHash)) {
                methodUID = tuidMap.get(testHash);
            }
        } else {
            try {
                ITestNGMethod testNGMethod = result.getMethod();

                Parameter[] parameters = result.getTestClass()
                        .getRealClass()
                        .getMethod(testNGMethod.getMethodName(),
                                testNGMethod.getParameterTypes())
                        .getParameters();

                for (int i = 0; i < parameters.length; i++) {
                    if (parameters[i].getName().equalsIgnoreCase(SpecialKeywords.TUID)) {
                        // AUTO-274 "Pass"ing status set on emailable report when a test step fails
                        if (result.getParameters()[i] == null) {
                            break;
                        }

                        methodUID = result.getParameters()[i].toString();
                        if (methodUID.contains(SpecialKeywords.TUID + ":")) {
                            methodUID = methodUID.replace(SpecialKeywords.TUID + ":", "");
                        }
                        break;
                    }
                }
            } catch (NoSuchMethodException e) {
                LOGGER.error("For some reason test method not found using reflection: {}", result.getMethod().getMethodName());
            }
        }
        return methodUID;
    }
    
    /**
     * get Test Method name
     * 
     * @param result ITestResult
     * @return String method name
     */
    @Deprecated(since = "8.0.1", forRemoval = true)
    public static String getMethodName(ITestResult result) {
        // adjust testName using pattern
        ITestNGMethod m = result.getMethod();
        String name = Configuration.get(Configuration.Parameter.TEST_NAMING_PATTERN);
        LOGGER.debug("TestNamingPattern: " + name);
        name = name.replace(SpecialKeywords.METHOD_NAME, m.getMethodName());
        name = name.replace(SpecialKeywords.METHOD_PRIORITY, String.valueOf(m.getPriority()));
        name = name.replace(SpecialKeywords.METHOD_THREAD_POOL_SIZE, String.valueOf(m.getThreadPoolSize()));
        name = name.replace(SpecialKeywords.METHOD_GROUP_NAMES, Arrays.toString(m.getGroups()));

        if (m.getDescription() != null) {
            LOGGER.debug("Test method description: " + m.getDescription());
            name = name.replace(SpecialKeywords.METHOD_DESCRIPTION, m.getDescription());
        } else {
            name = name.replace(SpecialKeywords.METHOD_DESCRIPTION, "");
        }
        
        return name;
    }
    
    /**
     * get Test Package name
     * 
     * @param result ITestResult
     * @return String package name
     */
    public static String getPackageName(ITestResult result) {
        return result.getMethod().getRealClass().getPackage().getName();
    }
    
    /**
     * calculate InvocationCount number based on test name
     * 
     * @param testResult ITestResult
     * @return int invCount
     */
    private static String appendInvocationCount(ITestResult testResult, String testName) {
        int expectedInvocationCount = getInvocationCount(testResult);
        if (expectedInvocationCount > 1) {
            // adding extra zero at the beginning of the invocation count
            int indexMaxLength = Integer.toString(expectedInvocationCount).length() + 1;
            String lineFormat = " [InvCount=%0" + indexMaxLength + "d]";
            int currentInvocationCount = testNameInvCounter.computeIfAbsent(testName, $ -> new AtomicInteger(0))
                                                             .incrementAndGet();
            testName += String.format(lineFormat, currentInvocationCount);
        }
        return testName;
    }
    private static int getInvocationCount(ITestResult testResult) {
        ITestNGMethod[] methods = testResult.getTestContext().getAllTestMethods();
        return Arrays.stream(methods)
                     .filter(method -> method.equals(testResult.getMethod()))
                     .findFirst()
                     .map(ITestNGMethod::getInvocationCount)
                     .orElse(0);
    }
    
    private static String appendDataProviderLine(ITestResult testResult, String testName) {
        ITestNGMethod testMethod = testResult.getMethod();
        ITestContext testContext = testResult.getTestContext();
        Object[] parameters = testResult.getParameters();

        int dataProviderSize = RunContextService.getDataProviderSize(testMethod, testContext);

        if (dataProviderSize > 0) {
            // adding extra zero at the beginning of the data provider line number
            int indexMaxLength = Integer.toString(dataProviderSize).length() + 1;
            String lineFormat = " [L%0" + indexMaxLength + "d]";
            int index = RunContextService.getCurrentDataProviderIndex(testMethod, testContext, parameters) + 1;
            testName += String.format(lineFormat, index);
        }
        return testName;
    }
    
}
